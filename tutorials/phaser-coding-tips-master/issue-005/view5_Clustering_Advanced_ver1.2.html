<!DOCTYPE html>
<html>
	<head>
		<title>Clustering2</title>
		<script type="text/javascript" src="resource/js/jquery-3.1.0.min.js"></script>
		<script type="text/javascript" src="resource/js/phaser.min.js"></script>
		<script type="text/javascript" src="resource/js/randomColor.js"></script>
		<script>
		function ClusteringNode(vehicle_list, options) {
			this._$init.apply(this, arguments);
		}

		ClusteringNode.prototype = {
			_$init: function(vehicle_list, options) {
				/*자동차 개체 리스트*/
				this._vehicle_list = vehicle_list;
				/*클러스터 개체 가변배열 리스트*/
				this._cluster_list = [];
				this._cluster_num = 0;

				if(options == undefined) {
					/*Operating Constructors.*/
					options = {};
				}				
				this._game = options.game || new Phaser.Game(0, 0, Phaser.Auto, '', {});
				/*value of arc-tan*/
				/*앞의 것이 undefined면 뒤의 10을 넣는다는 의미.*/
				this._vel_div_ratio = options.vel_div_ratio || 10;
				this._dist_scale = options.dist_scale || 500;

				/*좌우 15도까지 클러스터로 감지하겠다.*/
				this._angle_tole = options.angle_tole || (7*(Math.PI / 36));
			},

			init: function() {
				vehicle_list = this._vehicle_list;

				/*cluster 집단 -> cluster -> vehicle 리스트.*/
				for(i in vehicle_list) {
					vehicle_list[i].cluster = -1;
				}

				this._cluster_list = [];
				this._cluster_num = 0;

				return this;
			},

			getVehicleList: function() {
				return this._vehicle_list;
			},

			getClusterList: function() {
				return this._cluster_list;
			},

			getSize: function() {
				return this._cluster_num;
			},

			cluster: function() {
				this.init();	

				vehicle_list = this._vehicle_list;
				cluster_list = this._cluster_list;
				
				for(i in vehicle_list) {
					if(vehicle_list[i].cluster == -1) {
						cluster_list.push({
							first: vehicle_list[i],
							last: vehicle_list[i],
							vehicle_list: [vehicle_list[i]]
						});
						vehicle_list[i].cluster = this._cluster_num;
						this._repeat(vehicle_list[i]);
						this._cluster_num += 1;
					}
				}

				return this;
			},

			_repeat: function(vehicle) {
				/*recursive하게 클러스터를 늘려가는 과정.*/
				vehicle_list = this._vehicle_list;
				cluster_num = this._cluster_num;
				cluster_list = this._cluster_list;

				for(i in vehicle_list) {
					if(vehicle_list[i] != vehicle && vehicle_list[i].cluster == -1) {
						var switch_pos = this._satisfy(vehicle_list[i], vehicle)

						if(switch_pos != 'false') {
							console.log(vehicle.name + ' - ' + vehicle_list[i].name);

							vehicle_list[i].cluster = cluster_num;
							cluster_list[cluster_num].vehicle_list.push(vehicle_list[i]);

							if(cluster_list[cluster_num].first == vehicle && switch_pos == 'front') {
								cluster_list[cluster_num].first = vehicle_list[i];
							}

							if(cluster_list[cluster_num].last == vehicle && switch_pos == 'rear') {
								cluster_list[cluster_num].last = vehicle_list[i];
							}

							/*Recursive*/
							this._repeat(vehicle_list[i]);
						}
					}
				}
			},

			/*satisfy -> return : false, front, rear
				1. 범위에 들어오는 지.
				2. 첫번째인지 라스트인지.
			*/
			_satisfy: function(src, trgt) {
				var src_sprite = src.sprite;
				var trgt_sprite = trgt.sprite;

				// console.log('[SATISFY] ' + src.name + ' - ' + src.trgt);

				var src_dst = this._getDetectDst(src.vel);
				var trgt_dst = this._getDetectDst(trgt.vel);
				var bet_dst = this._game.physics.arcade.distanceBetween(src_sprite, trgt_sprite);

				//console.log('dst: ' + src_dst + ' / ' + trgt_dst +' / ' + bet_dst);

				if(src_dst < bet_dst || trgt_dst < bet_dst) {
					return 'false';
				}

				var src_rot = src_sprite.rotation;
				var trgt_rot = trgt_sprite.rotation;
				var bet_rot = this._game.physics.arcade.angleBetween(src_sprite, trgt_sprite);

				//console.log('rot: ' + src_rot + ' / ' + trgt_rot + ' / ' + bet_rot);
				var switch_pos = this._isInLine(src_rot, trgt_rot, bet_rot)

				if( switch_pos == 'front') {
					return 'front';
				} else if (switch_pos == 'rear') {
					return 'rear';
				}else {
					return 'false';
				}
			},

			/*차간 거리를 측정함. arc tan이용.*/
			_getDetectDst: function(vel) {
				return (Math.atan(-(Math.floor(vel / this._vel_div_ratio))) + (Math.PI / 2)) * 300;
				//return (1 + (1/(vel+1)))*250;
			},

			_isInLine: function(src_rot, trgt_rot, bet_rot) {
				if(!this._isParallel(src_rot, trgt_rot)) {
					return 'false';
				}

				var rev_bet_rot = this._game.math.reverseAngle(bet_rot);

				if(this._isParallel(src_rot, bet_rot)) {
					if(this._isParallel(trgt_rot, bet_rot)) {
						return 'rear';
					}
				} else if(this._isParallel(src_rot, rev_bet_rot)) {
					if(this._isParallel(trgt_rot, rev_bet_rot)) {
						return 'front';
					}
				} else {
					return 'false';
				}
			},

			_isParallel: function(angle1, angle2) {
				var diff = this._game.math.normalizeAngle(angle1 - angle2);

				if(diff < this._angle_tole || diff > (Math.PI * 2 - this._angle_tole)) {
					return true;
				} else {
					return false;
				}
			}
		};
	</script>
	</head>

	<body>
		<div id="viewport"></div>
		<div id="setting">
			<button onclick="processClusteringDriver()">Cluster</button>
		</div>

		<div>
			<button onclick="detection1()">Detecting1</button>
		</div>
	</body>
	<script>
		/*Making More Real Situation.*/
		var screen_width = 500;
		var screen_height = 800;
		var vehicle_list = [];
		var sprites;
		
		var game = new Phaser.Game(screen_width, screen_height, Phaser.Auto, 'viewport', {
				preload: preload,
				create: create,
				update: update
		});
		
		function preload() {
			var assetFolderDir = 'resource/assets/';
			game.load.image('star', assetFolderDir + 'star.png');
			game.load.image('car', assetFolderDir + 'car90.png');
		}
		
		function create() {
			game.stage.backgroundColor = '#0072bc';
		
			game.physics.startSystem(Phaser.Physics.ARCADE);
			
			sprites = game.add.group();
			
			for(var i = 0; i < 7; i ++) {
				var vehicle = {};
				
				var style = {
					font: '15px Courier',
					fill: '#ffffff'
				};

				var sprite = sprites.create(
					game.rnd.integerInRange(150, screen_width - 150),
					game.rnd.integerInRange(50, screen_height - 50),
					'car'
				);
				sprite.anchor.setTo(0.5, 0.5);
				sprite.angle = game.rnd.integerInRange(-80, -100);
				vehicle.sprite = sprite;
				
				vehicle.name = 'Car' + i;
				vehicle.vel = game.rnd.integerInRange(0, 100);
				vehicle.cluster = -1;
				
				vehicle_list[i] = vehicle;
			}
		}
		
		function update() {
			
		}
	</script>

	<script>
		/*vehicle_list -> 자동차 객체, game -> 게임 객체.
		 
		*/
		/*{} <- key, value.*/
		/*option <- game, dist_scale*/
		var clusteringNode = new ClusteringNode(vehicle_list, {
			game: game,
			dist_scale: 500
		});

		var style = {
			font: '12px Courier',
			fill: '#ffffff'
		};

		var clusterList;

		function processClusteringDriver() {
			//cluster가 이 호출로 인해 끝남.
			clusteringNode.cluster();

			clusterList = clusteringNode.getClusterList();
			/*
			<pseudo-code for detecting accident>
			Here, we detect the accident.
			var loopCnt1, loopCnt2;
			for(loopCnt1=0; loopCnt1<clusterList.getSize(); loopCnt1++){
				for(loopCnt2=loopCnt1+1; loopCnt<clusterList.getSize(); loopCnt2++){
					psudo code :
						if clusterList[loopCnt1].first is overlapped with clusterList[loopCnt2].last

							-> alert : clusterList[loopCnt1] : 너가 가해자야.
									 : clusterList[loopCnt2] : 너가 피해자야.
						else if clusterList[loopCnt2].first is overlapped with clusterList[loopCnt1].last
							-> alert : clusterList[loopCnt2] : 너가 가해자야.
									   clusterList[loopCnt1] : 너가 피해자야.
						else
							-> no 관련.
				}
			}
			*/			
			var colorList = randomColor({
				luminosity: 'dark',
				count: clusterList.length
			});

			for(i in clusterList) {
				colorNum = parseInt('0x' + colorList[i].substring(1), 16);
				var arcDrawing_first = clusterList[i].first;
				var arcDrawing_last = clusterList[i].last;
				
				/*arc addition*/
				
				var arc1 = game.add.graphics(0, 0);
				arc1.clear();
				arc1.lineStyle(1, 0xffffff);
				arc1.beginFill(colorNum, 0.1);
				arc1.arc(arcDrawing_first.sprite.x, arcDrawing_first.sprite.y,
					clusteringNode._getDetectDst(arcDrawing_first.vel),
					arcDrawing_first.sprite.rotation + clusteringNode._angle_tole,
					arcDrawing_first.sprite.rotation - clusteringNode._angle_tole,
					true
				);
				arc1.endFill();
				

				var arc2 = game.add.graphics(0, 0);
				arc2.clear();
				arc2.lineStyle(1, 0xffffff);
				arc2.beginFill(colorNum, 0.1);
				arc2.arc(arcDrawing_last.sprite.x, arcDrawing_last.sprite.y,
					clusteringNode._getDetectDst(arcDrawing_last.vel),
					game.math.reverseAngle(arcDrawing_last.sprite.rotation) + clusteringNode._angle_tole,
					game.math.reverseAngle(arcDrawing_last.sprite.rotation) - clusteringNode._angle_tole,
					true
				);
				arc2.endFill();
				/*arc addition*/
				
				for(j in clusterList[i].vehicle_list) {
					var vehicle = clusterList[i].vehicle_list[j];
					var sprite = vehicle.sprite;

					var name_text = game.add.text(0,0,'N:' + vehicle.name, style);
					name_text.alignTo(sprite, Phaser.LEFT_TOP, 5);

					var cluster_text = game.add.text(0, 0, 'C:' + i, style);
					cluster_text.alignTo(sprite, Phaser.RIGHT_TOP, 5);

					var vel_text = game.add.text(0, 0, 'V:' + vehicle.vel, style);
					vel_text.alignTo(sprite, Phaser.RIGHT_BOTTOM, 5);

					var graphics = game.add.graphics(0, 0);
					graphics.clear();
					graphics.lineStyle(1, 0xffffff);
					graphics.beginFill(colorNum, 0.6);
					graphics.drawCircle(sprite.x, sprite.y, 40);
					graphics.endFill();
					
				}

				if(clusterList[i].first != clusterList[i].last) {
					var order_text = game.add.text(0, 0, 'First of ' +  i, style);
					order_text.alignTo(clusterList[i].first.sprite, Phaser.LEFT_BOTTOM, 5);

					order_text = game.add.text(0,0, 'Last of ' + i, style);
					order_text.alignTo(clusterList[i].last.sprite, Phaser.LEFT_BOTTOM, 5);
				}
			}
		}
	</script>
	<script>
		var relation = [];

		function detection1(){
			clusteringNode.cluster();
			var clusterList1 = clusteringNode.getClusterList();
			var count_clusterList = clusteringNode.getSize();

			/*내부에서만 쓸 수 있음.*/
			var vel_div_ratio = 10;
			var dist_scale = 500;

			function getDetectDst_Danger(vel){
				return (Math.atan(-(Math.floor(vel / vel_div_ratio))) + (Math.PI / 2)) * dist_scale;
				//return (1 + (1/(vel+1)))*200;
			}

			for(var i=0; i<count_clusterList; i++){
				for(var j=i+1; j<count_clusterList; j++){
					var std_cluster = clusterList1[i];
					var other_cluster = clusterList1[j];

					var other_center;
					var std_center;
					
					var danger_area1 = getDetectDst_Danger(clusterList1[i].last.vel);
					var danger_area2 = getDetectDst_Danger(clusterList1[j].last.vel);

					/*Posible to be a Killer*/
					other_center1 = clusterList1[j].first;
					/*Posible to be a Victim*/
					std_center1 = clusterList1[i].last;

					/*Posible to be a Killer*/
					other_center2 = clusterList1[i].first;
					/*Posible to be a Victim*/
					std_center2 = clusterList1[j].last;
					
					var test_distance1 = game.physics.arcade.distanceBetween(std_center1.sprite, other_center1.sprite);
					var test_distance2 = game.physics.arcade.distanceBetween(std_center2.sprite, other_center2.sprite);

					if((test_distance1 <= danger_area1) && isEffectivePosition(other_center1, std_center1)){
						//std가 피해자고, other가 가해자.
						console.log(j+' is killer. and '+i+' is victim.');
						//relation.push({victim: i, killer: j});
					} else if(test_distance2 <= danger_area2 && isEffectivePosition(other_center2, std_center2)){
						console.log(i+' is killer. and '+j+' is victim.');
						//relation.push({victim: j, killer: i});
					}
					else{
						//관련이 없음.
						console.log(i+' and '+j+' are not correlated.');
					}
				}
			}
		}
	</script>
	<script>
		function isEffectivePosition(killer, victim){
			/*Must be use function : angleBetween*/
			var vel_div_ratio = 10;
			var dist_scale = 500;
			function getDetectDst_Danger(vel){
				return (Math.atan(-(Math.floor(vel / vel_div_ratio))) + (Math.PI / 2)) * dist_scale;
				//return (1 + (1/(vel+1)))*200;
			}
			var diff = game.physics.arcade.angleBetween(killer.sprite, victim.sprite);
			
			if(Math.abs(victim.sprite.rotation - diff) < Math.PI * (7 / 36) ) {
				if(Math.abs(killer.sprite.rotation - diff) < 0.174533 ) {
					if(killer.vel <= victim.vel){
						return false;
					}
					/*
					var test_safe_dist = game.physics.arcade.distanceBetween(killer.sprite, victim.sprite);
					var avoid_dist_killer = getDetectDst_Danger(killer.vel);
					if(test_safe_dist < avoid_dist_killer){
						var diff2 = game.physics.arcade.angleBetween(victim.sprite, killer.sprite)
						
						if(Math.abs(killer.sprite.rotation - diff2) < Math.PI*(7/36)){
							return false;
						}
					}
					*/
					/*
					if() {
						return true;
					}
					*/
					return true;
				}
			}
			return false;
			
			
			/*
			var killer_xPos = killer.sprite.x;
			var killer_yPos = killer.sprite.y;
			var victim_xPos = victim.sprite.x;
			var victim_yPos = victim.sprite.y;

			var killer_angle = convertToDegree(normalizeRadian(killer.sprite.rotation));
			var victim_angle = convertToDegree(normalizeRadian(victim.sprite.rotation));
			var diffAngle = (killer_angle - victim_angle);

			var diffVector_xPos = (victim_xPos - killer_xPos);
			var diffVector_yPos = (victim_yPos - killer_yPos);
			var diffVector_length = Math.sqrt(Math.pow(diffVector_xPos, 2) + Math.pow(diffVector_yPos, 2));
			var diffVectorAngle = -(convertToDegree(normalizeRadian(Math.acos(diffVector_xPos/diffVector_length))));

			//if(Math.abs(victim_angle-diffVectorAngle)<30){
			if(game.physics.arcade.angleBetween(killer.sprite, victim.sprite)<0){
				if(Math.abs(killer_angle-diffVectorAngle)<35){
					if(killer.vel <= victim.vel){
						return false;
					}
					else if (Math.abs(diffVectorAngle-(-victim_angle))<10){
						return true;
					}
					
					return true;
				}
				return false;
			}
			else{
				return false;
			}
			*/
		}
		function normalizeDegree(angleDeg) {
			var mod_angle = angleDeg % 360;
			if(mod_angle > 180) {
				mod_angle = mod_angle - 360;
			} else if (mod_angle <= -180) {
				mod_angle = mod_angle + 360;
			}
			return mod_angle;
		}

		function normalizeRadian(angleRad) {
			var mod_angle = angleRad % (Math.PI * 2);
			if(mod_angle > Math.PI) {
				mod_angle = mod_angle - (Math.PI * 2);
			} else if (mod_angle <= -Math.PI) {
				mod_angle = mod_angle + (Math.PI * 2);
			}
			return mod_angle;
		}

		function convertToRadian(angleDeg) {
			var norm_deg = normalizeDegree(angleDeg);
			return norm_deg * Math.PI / 180;
		}

		function convertToDegree(angleRad) {
			var norm_rad = normalizeRadian(angleRad);
			return norm_rad * 180 / Math.PI;
		}
	</script>
</html>