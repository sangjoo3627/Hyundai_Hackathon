<!DOCTYPE html>
<html>
	<head>
		<title>Intersection</title>
		<script type="text/javascript" src="resource/js/jquery-3.1.0.min.js"></script>
		<script type="text/javascript" src="resource/js/phaser.min.js"></script>
		<script type="text/javascript" src="resource/js/randomColor.js"></script>
		<script>
		
		function IntersectionNode (intersection_center, clusterList, clusterList_num){
			this.cluster_list = clusterList;
			this.cluster_num = clusterList_num;
			this.center = intersection_center;
			// 위험 cluster를 담아 놓는 list
			this.danger_cluster_list = [];
			
			// 도로에서 center로 향하는 방향 각도 (사거리)
			this.angle = [180, -90, 0, 90];

			// 각 도로들(사거리) 내에 존재하는 cluster를 담는 list
			this.road = [[],[],[],[]];

			// 신호등 정보
			// 0(정지), 1(직진), 2(좌회전), 3(직진,좌회전)
			this.signal = [3,0,0,0];
			
			// center에서 진입하는 cluster까지의 감지 범위
			this.center_dist = 200;
			// center에서 4가지 방향의 도로 정지선까지의 거리
			this.stopline = 50;
			
			// 교차로에 진입하는 cluster를 감지하고 위험요소를 판단하는 함수
			this.check_cluster = function (){
				// cluster 하나씩 꺼내 교차로 내 존재하는지 판단
				for(var i=0; i<this.cluster_num; i++){
					var checked_cluster = this.cluster_list[i];
					var test_distance = game.physics.arcade.distanceBetween(this.center, checked_cluster.first.sprite);
					var danger_vel = 50;
					
					// 해당 cluster가 center의 범위내에 닿았을 때 road_list에 담고 신호등 체크
					if(test_distance <= this.center_dist)
					{
						// 진입하는 cluster의 방향 각도
						var test_angle = convertToDegree(normalizeRadian(checked_cluster.first.sprite.rotation));
						
						for(var j=0; j<4; j++){
							var angle_bet = convertToDegree(normalizeRadian(game.physics.arcade.angleBetween(checked_cluster.first.sprite, this.center)));
							// road로 진입하는 방향이고 정지선 전에 존재하는 cluster일 경우
							if(test_angle == this.angle[j] && (angle_bet >= test_angle-90) && (angle_bet <= test_angle+90)){
								this.road[j].push(checked_cluster);
								// 빨간불이고 정지선 부근임에도 일정 속도 이상 내고 있을 경우 위험 요소 리스트에 넣음
								if((this.signal[j] == 0) && (checked_cluster.first.vel > danger_vel)){
									this.danger_cluster_list.push(checked_cluster);
								}
							}
						}
					}
				}
				
				// danger_list에 무언가 들어있을때 (위험 차량이 존재 할 경우)
				if(this.danger_cluster_list.length != 0){
					for(k in this.danger_cluster_list){
						var style = {
							font: '12px Courier',
							fill: '#ff0000'
						};
						var sprite = this.danger_cluster_list[k].first.sprite;
						var danger_text = game.add.text(0,0, this.danger_cluster_list[k].first.name + ' is Dangerous!!!', style);
						danger_text.alignTo(sprite, Phaser.LEFT_BOTTOM, 5);

						var graphics = game.add.graphics(0, 0);
						graphics.clear();
						graphics.lineStyle(1, 0xffffff);
						graphics.beginFill(colorNum, 0.6);
						graphics.endFill();
					}
				}
			}
		}
		
		</script>
		<script>
		function ClusteringNode(vehicle_list, options) {
			this._$init.apply(this, arguments);
		}

		ClusteringNode.prototype = { 
			_$init: function(vehicle_list, options) {
				/*자동차 개체 리스트*/
				this._vehicle_list = vehicle_list;
				/*클러스터 개체 가변배열 리스트*/
				this._cluster_list = [];
				this._cluster_num = 0;

				if(options == undefined) {
					/*Operating Constructors.*/
					options = {};
				}				
				this._game = options.game || new Phaser.Game(0, 0, Phaser.Auto, '', {});
				/*value of arc-tan*/
				/*앞의 것이 undefined면 뒤의 10을 넣는다는 의미.*/
				this._vel_div_ratio = options.vel_div_ratio || 10;
				this._dist_scale = options.dist_scale || 500;

				/*좌우 15도까지 클러스터로 감지하겠다.*/
				this._angle_tole = options.angle_tole || (7*(Math.PI / 36));
			},

			init: function() {
				vehicle_list = this._vehicle_list;

				/*cluster 집단 -> cluster -> vehicle 리스트.*/
				for(i in vehicle_list) {
					vehicle_list[i].cluster = -1;
				}

				this._cluster_list = [];
				this._cluster_num = 0;

				return this;
			},

			getVehicleList: function() {
				return this._vehicle_list;
			},

			getClusterList: function() {
				return this._cluster_list;
			},

			getSize: function() {
				return this._cluster_num;
			},

			cluster: function() {
				this.init();	

				vehicle_list = this._vehicle_list;
				cluster_list = this._cluster_list;
				
				for(i in vehicle_list) {
					if(vehicle_list[i].cluster == -1) {
						cluster_list.push({
							first: vehicle_list[i],
							last: vehicle_list[i],
							vehicle_list: [vehicle_list[i]]
						});
						vehicle_list[i].cluster = this._cluster_num;
						this._repeat(vehicle_list[i]);
						this._cluster_num += 1;
					}
				}

				return this;
			},

			_repeat: function(vehicle) {
				/*recursive하게 클러스터를 늘려가는 과정.*/
				vehicle_list = this._vehicle_list;
				cluster_num = this._cluster_num;
				cluster_list = this._cluster_list;

				for(i in vehicle_list) {
					if(vehicle_list[i] != vehicle && vehicle_list[i].cluster == -1) {
						var switch_pos = this._satisfy(vehicle_list[i], vehicle)

						if(switch_pos != 'false') {
							console.log(vehicle.name + ' - ' + vehicle_list[i].name);

							vehicle_list[i].cluster = cluster_num;
							cluster_list[cluster_num].vehicle_list.push(vehicle_list[i]);

							if(cluster_list[cluster_num].first == vehicle && switch_pos == 'front') {
								cluster_list[cluster_num].first = vehicle_list[i];
							}

							if(cluster_list[cluster_num].last == vehicle && switch_pos == 'rear') {
								cluster_list[cluster_num].last = vehicle_list[i];
							}

							/*Recursive*/
							this._repeat(vehicle_list[i]);
						}
					}
				}
			},

			/*satisfy -> return : false, front, rear
				1. 범위에 들어오는 지.
				2. 첫번째인지 라스트인지.
			*/
			_satisfy: function(src, trgt) {
				var src_sprite = src.sprite;
				var trgt_sprite = trgt.sprite;

				// console.log('[SATISFY] ' + src.name + ' - ' + src.trgt);

				var src_dst = this._getDetectDst(src.vel);
				var trgt_dst = this._getDetectDst(trgt.vel);
				var bet_dst = this._game.physics.arcade.distanceBetween(src_sprite, trgt_sprite);

				//console.log('dst: ' + src_dst + ' / ' + trgt_dst +' / ' + bet_dst);

				if(src_dst < bet_dst || trgt_dst < bet_dst) {
					return 'false';
				}

				var src_rot = src_sprite.rotation;
				var trgt_rot = trgt_sprite.rotation;
				var bet_rot = this._game.physics.arcade.angleBetween(src_sprite, trgt_sprite);

				//console.log('rot: ' + src_rot + ' / ' + trgt_rot + ' / ' + bet_rot);
				var switch_pos = this._isInLine(src_rot, trgt_rot, bet_rot)

				if( switch_pos == 'front') {
					return 'front';
				} else if (switch_pos == 'rear') {
					return 'rear';
				}else {
					return 'false';
				}
			},

			/*차간 거리를 측정함. arc tan이용.*/
			_getDetectDst: function(vel) {
				return (Math.atan(-(Math.floor(vel / this._vel_div_ratio))) + (Math.PI / 2)) * 300;
				//return (1 + (1/(vel+1)))*250;
			},

			_isInLine: function(src_rot, trgt_rot, bet_rot) {
				if(!this._isParallel(src_rot, trgt_rot)) {
					return 'false';
				}

				var rev_bet_rot = this._game.math.reverseAngle(bet_rot);

				if(this._isParallel(src_rot, bet_rot)) {
					if(this._isParallel(trgt_rot, bet_rot)) {
						return 'rear';
					}
				} else if(this._isParallel(src_rot, rev_bet_rot)) {
					if(this._isParallel(trgt_rot, rev_bet_rot)) {
						return 'front';
					}
				} else {
					return 'false';
				}
			},

			_isParallel: function(angle1, angle2) {
				var diff = this._game.math.normalizeAngle(angle1 - angle2);

				if(diff < this._angle_tole || diff > (Math.PI * 2 - this._angle_tole)) {
					return true;
				} else {
					return false;
				}
			}
		};
	</script>
	</head>

	<body>
		<div id="viewport"></div>
		<div id="setting">
			<button onclick="processClusteringDriver()">Cluster</button>
		</div>

		<div id="setting_holder">
			<button onclick="addVehicle()">ADD</button>
			<form id="config" onSubmit="changeConfig(); return false;">
				<input name="veh_name" type="text" />
				<input name="pos_x" type="number" />
				<input name="pos_y" type="number" />
				<input name="vel" type="number" min="0" max="150" />
				<input name="angle" type="number" />
				<input type="submit" val="Change" />
			</form>
		</div>
		<!--
		<div>
			<button onclick="detection1()">Detecting1</button>
		</div>
		-->
	</body>
	<script>
		/*Making More Real Situation.*/
		var screen_width = 1000;
		var screen_height = 600;
		var vehicle_list = [];
		var intersection_center;
		var sprites;
		var vehicle_num = 0;
		var selected_vehicle = {};
		var form_center = $('form#interset');
		var form = 	$('form#config');
		
		var game = new Phaser.Game(screen_width, screen_height, Phaser.Auto, 'viewport', {
				preload: preload,
				create: create,
				update: update
		});
		
		function preload() {
			var assetFolderDir = 'resource/assets/';
			game.load.image('star', assetFolderDir + 'star.png');
			game.load.image('car', assetFolderDir + 'car90.png');
			game.load.image('dot', assetFolderDir + 'dot.png');
		}
		
		function create() {
			game.stage.backgroundColor = '#0072bc';
		
			game.physics.startSystem(Phaser.Physics.ARCADE);
			
			sprites = game.add.group();
			
			// center point를 'dot'으로 표현
			var stop_line = 50;
			var temp_center = {};
			var sprite = sprites.create(
				screen_width/2, 
				screen_height/2, 
				'dot'
			);
			sprite.anchor.setTo(0.5, 0.5);
			temp_center = sprite;
			
			temp_center.name = 'Intersection Center';
			intersection_center = temp_center;
			
			// center의 감지범위, 정지선, 도로 라인을 그림
			var graphics1 = game.add.graphics(0, 0);
			graphics1.clear();
			graphics1.lineStyle(1, 0xeaeaea);
			graphics1.beginFill(8, 0.2);
			graphics1.drawCircle(intersection_center.x, intersection_center.y, 400);
			graphics1.drawRect(intersection_center.x-stop_line, intersection_center.y-stop_line, stop_line*2, stop_line*2);
			graphics1.drawRect(intersection_center.x-screen_width/2, intersection_center.y-stop_line, screen_width, stop_line*2);
			graphics1.drawRect(intersection_center.x-stop_line, intersection_center.y-screen_height/2, stop_line*2, screen_height);
			graphics1.endFill();
			
			game.input.mouse.mouseWheelCallback = mouseWheel;
			game.input.mouse.mouseDownCallback = mouseDown;
		}
		
		function update() {
			
		}
	</script>

	<script>
		var clusteringNode = new ClusteringNode(vehicle_list, {
			game: game,
			dist_scale: 500
		});

		var style = {
			font: '12px Courier',
			fill: '#ffffff'
		};

		var clusterList;
		var clusterList_num;
		var intersectionNode;

		function processClusteringDriver() {
			//cluster가 이 호출로 인해 끝남.
			clusteringNode.cluster();

			clusterList = clusteringNode.getClusterList();
			clusterList_num = clusterList.length;
			
			var colorList = randomColor({
				luminosity: 'dark',
				count: clusterList_num
			});

			for(i in clusterList) {
				colorNum = parseInt('0x' + colorList[i].substring(1), 16);
				var arcDrawing_first = clusterList[i].first;
				var arcDrawing_last = clusterList[i].last;
				
				/*arc addition*/
				
				var arc1 = game.add.graphics(0, 0);
				arc1.clear();
				arc1.lineStyle(1, 0xffffff);
				arc1.beginFill(colorNum, 0.1);
				arc1.arc(arcDrawing_first.sprite.x, arcDrawing_first.sprite.y,
					clusteringNode._getDetectDst(arcDrawing_first.vel),
					arcDrawing_first.sprite.rotation + clusteringNode._angle_tole,
					arcDrawing_first.sprite.rotation - clusteringNode._angle_tole,
					true
				);
				arc1.endFill();
				

				var arc2 = game.add.graphics(0, 0);
				arc2.clear();
				arc2.lineStyle(1, 0xffffff);
				arc2.beginFill(colorNum, 0.1);
				arc2.arc(arcDrawing_last.sprite.x, arcDrawing_last.sprite.y,
					clusteringNode._getDetectDst(arcDrawing_last.vel),
					game.math.reverseAngle(arcDrawing_last.sprite.rotation) + clusteringNode._angle_tole,
					game.math.reverseAngle(arcDrawing_last.sprite.rotation) - clusteringNode._angle_tole,
					true
				);
				arc2.endFill();
				/*arc addition*/
				
				for(j in clusterList[i].vehicle_list) {
					var vehicle = clusterList[i].vehicle_list[j];
					var sprite = vehicle.sprite;

					var name_text = game.add.text(0,0,'N:' + vehicle.name, style);
					name_text.alignTo(sprite, Phaser.LEFT_TOP, 5);

					var cluster_text = game.add.text(0, 0, 'C:' + i, style);
					cluster_text.alignTo(sprite, Phaser.RIGHT_TOP, 5);

					var vel_text = game.add.text(0, 0, 'V:' + vehicle.vel, style);
					vel_text.alignTo(sprite, Phaser.RIGHT_BOTTOM, 5);

					var graphics = game.add.graphics(0, 0);
					graphics.clear();
					graphics.lineStyle(1, 0xffffff);
					graphics.beginFill(colorNum, 0.6);
					graphics.drawCircle(sprite.x, sprite.y, 40);
					graphics.endFill();
					
				}

				if(clusterList[i].first != clusterList[i].last) {
					var order_text = game.add.text(0, 0, 'First of ' +  i, style);
					order_text.alignTo(clusterList[i].first.sprite, Phaser.LEFT_BOTTOM, 5);

					order_text = game.add.text(0,0, 'Last of ' + i, style);
					order_text.alignTo(clusterList[i].last.sprite, Phaser.LEFT_BOTTOM, 5);
				}
			}
			
			// 교차로 객체 생성
			intersectionNode = new IntersectionNode(intersection_center, clusterList, clusterList_num);
			intersectionNode.check_cluster();
		}
		
	</script>
	<script>
		var relation = [];

		function detection1(){
			clusteringNode.cluster();
			var clusterList1 = clusteringNode.getClusterList();
			var count_clusterList = clusteringNode.getSize();

			/*내부에서만 쓸 수 있음.*/
			var vel_div_ratio = 10;
			var dist_scale = 500;

			function getDetectDst_Danger(vel){
				return (Math.atan(-(Math.floor(vel / vel_div_ratio))) + (Math.PI / 2)) * dist_scale;
				//return (1 + (1/(vel+1)))*200;
			}

			for(var i=0; i<count_clusterList; i++){
				for(var j=i+1; j<count_clusterList; j++){
					var std_cluster = clusterList1[i];
					var other_cluster = clusterList1[j];

					var other_center;
					var std_center;
					
					var danger_area1 = getDetectDst_Danger(clusterList1[i].last.vel);
					var danger_area2 = getDetectDst_Danger(clusterList1[j].last.vel);

					/*Posible to be a Killer*/
					other_center1 = clusterList1[j].first;
					/*Posible to be a Victim*/
					std_center1 = clusterList1[i].last;

					/*Posible to be a Killer*/
					other_center2 = clusterList1[i].first;
					/*Posible to be a Victim*/
					std_center2 = clusterList1[j].last;
					
					var test_distance1 = game.physics.arcade.distanceBetween(std_center1.sprite, other_center1.sprite);
					var test_distance2 = game.physics.arcade.distanceBetween(std_center2.sprite, other_center2.sprite);

					if((test_distance1 <= danger_area1) && isEffectivePosition(other_center1, std_center1)){
						//std가 피해자고, other가 가해자.
						console.log(j+' is killer. and '+i+' is victim.');
						//relation.push({victim: i, killer: j});
					} else if(test_distance2 <= danger_area2 && isEffectivePosition(other_center2, std_center2)){
						console.log(i+' is killer. and '+j+' is victim.');
						//relation.push({victim: j, killer: i});
					}
					else{
						//관련이 없음.
						console.log(i+' and '+j+' are not correlated.');
					}
				}
			}
		}
	</script>
	<script>
		function isEffectivePosition(killer, victim){
			/*Must be use function : angleBetween*/
			var vel_div_ratio = 10;
			var dist_scale = 500;
			function getDetectDst_Danger(vel){
				return (Math.atan(-(Math.floor(vel / vel_div_ratio))) + (Math.PI / 2)) * dist_scale;
				//return (1 + (1/(vel+1)))*200;
			}
			var diff = game.physics.arcade.angleBetween(killer.sprite, victim.sprite);
			
			if(Math.abs(victim.sprite.rotation - diff) < Math.PI * (7 / 36) ) {
				if(Math.abs(killer.sprite.rotation - diff) < 0.174533 ) {
					if(killer.vel <= victim.vel){
						return false;
					}
					
					var test_safe_dist = game.physics.arcade.distanceBetween(killer.sprite, victim.sprite);
					var avoid_dist_killer = getDetectDst_Danger(killer.vel);
					if(test_safe_dist < avoid_dist_killer){
						var diff2 = game.physics.arcade.angleBetween(victim.sprite, killer.sprite)
						
						if(Math.abs(killer.sprite.rotation - diff2) < Math.PI*(7/36)){
							return false;
						}
					}
					return true;
				}
			}
			return false;
		}
		
		function normalizeDegree(angleDeg) {
			var mod_angle = angleDeg % 360;
			if(mod_angle > 180) {
				mod_angle = mod_angle - 360;
			} else if (mod_angle <= -180) {
				mod_angle = mod_angle + 360;
			}
			return mod_angle;
		}

		function normalizeRadian(angleRad) {
			var mod_angle = angleRad % (Math.PI * 2);
			if(mod_angle > Math.PI) {
				mod_angle = mod_angle - (Math.PI * 2);
			} else if (mod_angle <= -Math.PI) {
				mod_angle = mod_angle + (Math.PI * 2);
			}
			return mod_angle;
		}

		function convertToRadian(angleDeg) {
			var norm_deg = normalizeDegree(angleDeg);
			return norm_deg * Math.PI / 180;
		}

		function convertToDegree(angleRad) {
			var norm_rad = normalizeRadian(angleRad);
			return norm_rad * 180 / Math.PI;
		}
	</script>
	
	<script>
	function mouseDown(event) {
		var target_object = game.input.activePointer.targetObject;

		if(target_object == null) {
			if(selected_vehicle.sprite != null) {
				selected_vehicle.sprite.tint = 0xffffff;
				selected_vehicle = {};
				form.trigger('reset');
			}
		} else {
			if (selected_vehicle.sprite == null) {
				selectVehicle(target_object.sprite);

			} else if(target_object.sprite != selected_vehicle.sprite) {
				selected_vehicle.sprite.tint = 0xffffff;
				selectVehicle(target_object.sprite);
			}
		}
	}

	function mouseWheel(event) {
		if(selected_vehicle.sprite != null) {
			selected_vehicle.sprite.angle += game.input.mouse.wheelDelta * 5;
			form.find('[name=angle]').val(convertToDegree(selected_vehicle.sprite.rotation));
		}
	}

	function updateVehiclePos(sprite) {
		form.find('[name=pos_x]').val(sprite.x);
		form.find('[name=pos_y]').val(sprite.y);
	}	

	function selectVehicle(sprite) {
		sprite.tint = 0x99ff99;

		selected_vehicle = findVehicle(sprite);

		form.find('[name=veh_name]').val(selected_vehicle.name);
		form.find('[name=vel]').val(selected_vehicle.vel);
		form.find('[name=angle]').val(convertToDegree(selected_vehicle.sprite.rotation));
	}
	</script>
	
	<script>
	function addVehicle() {
		var added = {};

		var added_sprite = game.add.sprite(game.world.centerX, game.world.centerY, 'car');
		added_sprite.name = 'Car ' + vehicle_num;
		vehicle_num ++;
		added_sprite.anchor.setTo(0.5, 0.5);
		added_sprite.angle = -90;

		added_sprite.inputEnabled = true;
		added_sprite.input.enableDrag(true);
		added_sprite.input.enableSnap(16, 16, false, true);
		
		added_sprite.events.onDragUpdate.add(updateVehiclePos, this);
		
		added.sprite = added_sprite;

		added.vel = 0;
		added.name = added_sprite.name;

		vehicle_list.push(added);
	}

	function findVehicle(sprite) {
		var found = $.grep(vehicle_list, function(e) {
			return e.name == sprite.name;
		});

		if(found.length == 0) {
			return null;
		} else {
			return found[0];
		}
	}

	function changeConfig() {
		var name = form.find('[name=veh_name]').val();
		var x = parseInt(form.find('[name=pos_x]').val());
		var y = parseInt(form.find('[name=pos_y]').val());
		var vel = parseInt(form.find('[name=vel]').val());
		var angle = parseInt(form.find('[name=angle]').val());
		var rot = convertToRadian(angle);

		selected_vehicle.sprite.name = name;
		selected_vehicle.sprite.x = x;
		selected_vehicle.sprite.y = y;
		selected_vehicle.sprite.rotation = rot;

		selected_vehicle.name = name;
		selected_vehicle.vel = vel;

		return true;
	}
	</script>
</html>